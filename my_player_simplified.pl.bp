% vim: syntax=prolog:
act(Action, Knowledge) :-
  doAction(Action),
	saveKnowledge(Knowledge).

my_retrace(P) :- 
  retrace(P).
my_retrace(_).

saveAction(A) :-
  (
    ( oldActions(X), my_retrace(oldActions(_)))
    ; X = []),
  assert(oldActions([A|X])).

retraceAction(A) :-
  ( oldActions([A|T]),
    my_retrace(oldActions(_)),
    assert(oldActions(T))
  )
; ( A = exit).

valuableKnowledge([oldActions, turnLeftGoBack, goBack]).

saveKnowledge(K) :-
  saveOldActions(X, []),
  saveTurnLeftBack(Y, X),
  saveGoBack(K, Y).

saveOldActions(K, A) :-
  oldActions(X), !,
  K = [oldActions(X) | A].

saveOldActions(K,K).

saveTurnLeftBack(K, A) :-
  turnLeftGoBack(X), !,
  K = [turnLeftGoBack(X) | A].

saveTurnLeftBack(K, K).

saveGoBack(K, A) :-
  goBack(X), !,
  K = [goBack(X) | A ].

saveGoBack(K, K).

/*
  valuableKnowledge(X),
  saveKnowledge(K, X, []).

saveKnowledge(K, [], K).
saveKnowledge(K, [H|T], Kp) :-
  (
    (H(X), Kpp = [H(X) | Kp]) 
  ; Kpp = Kp ), 
  saveKnowledge(K, T, Kpp).
*/
doAction(A) :-
  goBack(P),
  retraceAction(X),
  reverseAction(X, A).

doAction(A) :-
  turnLeftGoBack(P), !,
  my_retrace(turnLeftGoBack(P)),
  A = turnLeft,
  assert(goBack([])).

doAction(A) :-
  glitter,
  A = grab.

doAction(A) :-
  (bump 
  ;breeze
  ;stench),
  return(A).

doAction(A) :-
  goForward(A),
  saveAction(A).

goForward(moveForward).

return(turnLeft) :-
  assert(turnLeftGoBack([])).

reverseAction(moveForward, moveForward).
reverseAction(turnLeft, turnRight).
reverseAction(turnRight, turnLeft).
reverseAction(exit, exit).
